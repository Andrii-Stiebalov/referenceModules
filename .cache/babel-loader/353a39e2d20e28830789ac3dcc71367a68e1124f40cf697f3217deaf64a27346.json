{"ast":null,"code":"export default function throttle(delay, callback, options) {\n  const {\n    noTrailing = false,\n    noLeading = false,\n    debounceMode = undefined\n  } = options || {};\n  let timeoutID;\n  let cancelled = false;\n  let lastExec = 0;\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  }\n  function cancel(options) {\n    const {\n      upcomingOnly = false\n    } = options || {};\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  function wrapper(...arguments_) {\n    let self = this;\n    let elapsed = Date.now() - lastExec;\n    if (cancelled) {\n      return;\n    }\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    function clear() {\n      timeoutID = undefined;\n    }\n    if (!noLeading && debounceMode && !timeoutID) {\n      exec();\n    }\n    clearExistingTimeout();\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        lastExec = Date.now();\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n  wrapper.cancel = cancel;\n  return wrapper;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}