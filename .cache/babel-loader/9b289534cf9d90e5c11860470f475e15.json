{"ast":null,"code":"const EventEmitter = {\n  _debug: false,\n  _events: new Map(),\n  _add(eventName, callback) {\n    if (this._debug) {\n      console.log(`Event \"${eventName}\" has been succesfully added`);\n    }\n    let eventList = [];\n    if (this._events.has(eventName)) {\n      eventList = this._events.get(eventName);\n    }\n    eventList.push(callback);\n    this._events.set(eventName, eventList);\n  },\n  _remove(eventName, callback) {\n    if (this._debug) {\n      console.log(`Event \"${eventName}\" has been succesfully removed`);\n    }\n    if (this._events.has(eventName)) {\n      let eventList = [];\n      if (callback !== undefined) {\n        eventList = this._events.get(eventName);\n        for (let i = 0; i < eventList.length; i++) {\n          if (eventList[i] === callback) {\n            eventList.splice(i, 1);\n            break;\n          }\n        }\n      }\n      if (eventList.length) {\n        this._events.set(eventName, eventList);\n      } else {\n        this._events.delete(eventName);\n      }\n    }\n  },\n  _call(eventName, ...args) {\n    if (this._debug) {\n      console.log(`Event \"${eventName}\" has been succesfully triggered`, ...args);\n    }\n    if (this._events && this._events.has(eventName)) {\n      this._events.get(eventName).forEach(callback => {\n        callback(...args);\n      });\n    }\n  },\n  _useSingle(isAdding, eventName, callback) {\n    if (typeof eventName === \"string\") {\n      if (typeof callback === \"function\") {\n        if (isAdding) {\n          this._add(eventName, callback);\n        } else {\n          this._remove(eventName, callback);\n        }\n      } else if (typeof callback === \"object\" && Array.isArray(callback)) {\n        let callbacks = callback;\n        if (callbacks.length) {\n          let checkTypes = callbacks.every(_callback => typeof _callback === \"function\");\n          if (checkTypes) {\n            callbacks.forEach(_callback => {\n              if (isAdding) {\n                this._add(eventName, _callback);\n              } else {\n                this._remove(eventName, _callback);\n              }\n            });\n          } else {\n            throw new Error(\"Array of Callbacks must contain only functions\");\n          }\n        } else {\n          throw new Error(\"Array of callbacks must have at least 1 element\");\n        }\n      } else {\n        throw new Error('\"callback\" type must be a function or array');\n      }\n    } else {\n      throw new Error('\"eventName\" type must be a string');\n    }\n  },\n  _use(isAdding, eventName, callback) {\n    if (eventName !== undefined) {\n      if (callback !== undefined) {\n        if (typeof eventName === \"string\") {\n          this._useSingle(isAdding, eventName, callback);\n        } else {\n          throw new Error('If you use this function only with 2 parameters, \"eventName\" must be a string');\n        }\n      } else if (typeof eventName === \"object\" && !Array.isArray(eventName)) {\n        let eventNames = eventName;\n        Object.entries(eventNames).forEach(([key, value]) => {\n          this._useSingle(isAdding, key, value);\n        });\n      } else if (typeof eventName === \"object\" && Array.isArray(eventName) && !isAdding) {\n        let eventNames = eventName;\n        if (eventNames.length) {\n          if (eventNames.every(_eventName => typeof _eventName === \"string\")) {\n            eventNames.forEach(_eventName => this._remove(_eventName));\n          } else {\n            throw new Error(\"Array of eventNames must contain only strings\");\n          }\n        } else {\n          throw new Error(\"Array of eventNames must have at least 1 element\");\n        }\n      } else if (typeof eventName === \"string\" && !isAdding) {\n        this._remove(eventName);\n      } else {\n        let allowedTypes = isAdding ? \"Object\" : \"Object / Array / String\";\n        throw new Error(`If you use this function only with 1 parameter, it must be ${allowedTypes}`);\n      }\n    } else {\n      throw new Error(`This function must contain at least 1 parameter`);\n    }\n  }\n};\nfunction createEventEmitter(debug = false) {\n  return Object.assign({}, EventEmitter, {\n    _events: new Map(),\n    _debug: debug\n  });\n}\nexport { EventEmitter, createEventEmitter };","map":null,"metadata":{},"sourceType":"module"}