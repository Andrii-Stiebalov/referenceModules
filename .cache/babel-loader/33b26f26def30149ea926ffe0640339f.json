{"ast":null,"code":"import Point from \"./Point.js\";\nimport cdt2d from \"cdt2d\";\nexport default {\n  mounted() {\n    this.canvas = this.$refs.canvas;\n    this.context = this.canvas.getContext(\"2d\");\n    this.restart();\n  },\n  data() {\n    return {\n      canvas: {},\n      context: {},\n      canvasHeight: 540,\n      canvasWidth: 1350,\n      overPoint: null,\n      dragMode: false,\n      finishedGame: false,\n      connectedWithOverPoint: null,\n      pointSize: 16,\n      pointsCount: 10,\n      intersectedCount: 0,\n      strokeStyle: \"darkgrey\",\n      fillStyle: \"#fff\",\n      lines: [],\n      points: [],\n      edges: null\n    };\n  },\n  computed: {},\n  methods: {\n    // {{{ restart\n    restart() {\n      this.lines = [];\n      this.edges = null;\n      this.finishedGame = false;\n      this.clearPoints();\n      this.generatePoints();\n      this.triangulate();\n      this.arrangePoints();\n      this.connectPoints();\n      this.drawAllNodes();\n    },\n    // }}}\n    // {{{ matchPoints\n    matchPoints(checkPoint, mousePoint) {\n      if (mousePoint.x > checkPoint.x + this.pointSize) {\n        return false;\n      }\n      if (mousePoint.x < checkPoint.x - this.pointSize) {\n        return false;\n      }\n      if (mousePoint.y > checkPoint.y + this.pointSize) {\n        return false;\n      }\n      if (mousePoint.y < checkPoint.y - this.pointSize) {\n        return false;\n      }\n      return true;\n    },\n    // }}}\n    // {{{ clear\n    clear() {\n      this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    },\n    // }}}\n    // {{{ levels\n    easyLevel() {\n      this.pointsCount = 8;\n      this.restart();\n    },\n    fairLevel() {\n      this.pointsCount = 10;\n      this.restart();\n    },\n    toughLevel() {\n      this.pointsCount = 15;\n      this.restart();\n    },\n    crazyLevel() {\n      this.pointsCount = 30;\n      this.restart();\n    },\n    // }}}\n    // {{{ clearPoints\n    clearPoints() {\n      this.points = [];\n      this.clear();\n    },\n    // }}}\n    // {{{ getMousePos\n    getMousePos(evt) {\n      // https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas\n      var rect = this.context.canvas.getBoundingClientRect();\n      return {\n        x: parseInt((evt.clientX - rect.left) / (rect.right - rect.left) * this.canvasWidth),\n        y: parseInt((evt.clientY - rect.top) / (rect.bottom - rect.top) * this.canvasHeight)\n      };\n    },\n    // }}}\n    // {{{ mouseup\n    mouseup(event) {\n      let mouseUpPoint = this.getMousePos(event);\n      if (this.dragMode && this.overPoint) {\n        this.dragPoint(this.overPoint, mouseUpPoint);\n        this.dragMode = false;\n        this.points.forEach(point => {\n          this.drawCircle(point, this.pointSize);\n        });\n        if (this.intersectedCount === 0 && !this.finishedGame && this.checkPoints(this.points)) {\n          this.playWin();\n        }\n      } else {\n        this.connectedWithOverPoint = null;\n        // this.addNode(mouseUpPoint)\n      }\n    },\n    // }}}\n    // {{{ dragPoint\n    dragPoint(selectedPoint, newPoint) {\n      if (this.finishedGame) {\n        return;\n      }\n      this.points.map(pointToMove => {\n        if (pointToMove.x === selectedPoint.x && pointToMove.y === selectedPoint.y) {\n          pointToMove.x = newPoint.x;\n          pointToMove.y = newPoint.y;\n          this.clear();\n          this.drawAllNodes();\n        }\n      });\n    },\n    // }}}\n    // {{{ mousemove\n    mousemove(event) {\n      let point = this.getMousePos(event);\n      // this.selectedPoint(point)\n      if (this.dragMode && this.overPoint) {\n        this.dragPoint(this.overPoint, point);\n      }\n    },\n    // }}}\n    // {{{ mousedown\n    mousedown(event) {\n      let point = this.getMousePos(event);\n      if (this.isMouseOnNode(point)) {\n        this.findConnectedWithOverPoint();\n        // point selected\n        this.dragMode = true;\n      } else {\n        this.dragMode = false;\n      }\n    },\n    // }}}\n    // {{{ isMouseOnNode\n    isMouseOnNode(point) {\n      return this.selectedPoint(point) !== null;\n    },\n    // }}}\n    // {{{ selectedPoint\n    selectedPoint(point) {\n      for (var iteratedPoint of this.points) {\n        if (this.matchPoints(iteratedPoint, point)) {\n          this.overPoint = iteratedPoint;\n          return iteratedPoint;\n        }\n      }\n      this.overPoint = null;\n      return null;\n    },\n    // }}}}\n    // {{{ addNode\n    addNode(point) {\n      this.context.save();\n      this.drawNode(point);\n      this.context.restore();\n      this.points.push(point);\n    },\n    checkPoints(points) {\n      let result = false;\n      for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n          if (points[i] !== points[j]) {\n            result = this.areCirclesIntersecting(points[i], points[j]);\n          }\n          if (result) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n    areCirclesIntersecting(point1, point2) {\n      // Вычисляем расстояние между центрами кругов\n      const x1 = point1.x;\n      const y1 = point1.y;\n      const x2 = point2.x;\n      const y2 = point2.y;\n      const distance = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);\n\n      // Проверяем, пересекаются ли круги\n      return distance < 32;\n    },\n    // }}}\n    // {{{ isIntersect\n    isIntersect(line1, line2) {\n      // convert line1 to general form of line: Ax+By = C\n      var a1 = line1.endPoint.y - line1.startPoint.y;\n      var b1 = line1.startPoint.x - line1.endPoint.x;\n      var c1 = a1 * line1.startPoint.x + b1 * line1.startPoint.y;\n\n      // convert line2 to general form of line: Ax+By = C\n      var a2 = line2.endPoint.y - line2.startPoint.y;\n      var b2 = line2.startPoint.x - line2.endPoint.x;\n      var c2 = a2 * line2.startPoint.x + b2 * line2.startPoint.y;\n\n      // calculate the intersection point\n      var d = a1 * b2 - a2 * b1;\n      // parallel when d is 0\n      // if (d === 0) {\n      //   return fals\n      // solve the interception point at (x, y)\n      var x = (b2 * c1 - b1 * c2) / d;\n      var y = (a1 * c2 - a2 * c1) / d;\n\n      // check if the intersection point is on both line segments\n      if ((this.isInBetween(line1.startPoint.x, x, line1.endPoint.x) || this.isInBetween(line1.startPoint.y, y, line1.endPoint.y)) && (this.isInBetween(line2.startPoint.x, x, line2.endPoint.x) || this.isInBetween(line2.startPoint.y, y, line2.endPoint.y))) {\n        return true;\n      }\n      // be default the given lines is not intersected.\n      return false;\n    },\n    // }}}\n    // {{{ isInBetween\n    // return true if b is between a and c,\n    // we exclude the result when a==b or b==c\n    isInBetween(a, b, c) {\n      // return false if b is almost equal to a or c.\n      // this is to eliminate some floating point when\n      // two value is equal to each other but different with 0.00000...0001\n      if (Math.abs(a - b) < 0.000001 || Math.abs(b - c) < 0.000001) {\n        return false;\n      }\n\n      // true when b is in between a and c\n      return a < b && b < c || c < b && b < a;\n    },\n    // }}}\n    // {{{ drawNode\n    drawNode(point) {\n      this.context.beginPath();\n      this.context.moveTo(point.x - this.pointSize, point.y - this.pointSize);\n      this.context.lineTo(point.x - this.pointSize, point.y + this.pointSize);\n      this.context.lineTo(point.x + this.pointSize, point.y + this.pointSize);\n      this.context.lineTo(point.x + this.pointSize, point.y - this.pointSize);\n      this.context.lineTo(point.x - this.pointSize, point.y - this.pointSize);\n      this.context.fillStyle = this.fillStyle;\n      this.context.fill();\n      this.context.strokeStyle = this.strokeStyle;\n      this.context.stroke();\n    },\n    // }}}\n    // {{{ findConnectedWithOverPoint\n    findConnectedWithOverPoint() {\n      if (this.connectedWithOverPoint && this.connectedWithOverPoint.overPoint === this.overPoint) {\n        return;\n      }\n      let connectedWithOverPoint = [];\n      this.lines.forEach(({\n        startPoint,\n        endPoint\n      }) => {\n        if (startPoint === this.overPoint) {\n          connectedWithOverPoint.push(endPoint);\n        } else if (endPoint === this.overPoint) {\n          connectedWithOverPoint.push(startPoint);\n        }\n      });\n      this.connectedWithOverPoint = {\n        overPoint: this.overPoint,\n        connectedPoints: connectedWithOverPoint\n      };\n    },\n    // }}}\n    // {{{ isPointConnectWithOverPoint\n    isPointConnectWithOverPoint(point) {\n      if (this.overPoint === point) {\n        return true;\n      }\n      if (!this.connectedWithOverPoint) {\n        return false;\n      }\n      if (this.connectedWithOverPoint.connectedPoints && this.connectedWithOverPoint.connectedPoints.includes(point)) {\n        return true;\n      }\n    },\n    // }}}\n    // {{{ drawCircle\n    drawCircle(point, radius) {\n      this.context.fillStyle = this.isPointConnectWithOverPoint(point) && this.dragMode ? \"#C9F32D1A\" : \"#5D71711A\";\n      this.context.beginPath();\n      this.context.arc(point.x, point.y, radius, 0, Math.PI * 2, true);\n      this.context.closePath();\n      this.context.fill();\n      this.context.fillStyle = this.isPointConnectWithOverPoint(point) && this.dragMode ? \"#C9F32D\" : \"#5D7171\";\n      this.context.beginPath();\n      this.context.arc(point.x, point.y, radius / 2.5, 0, Math.PI * 2, true);\n      this.context.closePath();\n      this.context.fill();\n    },\n    // }}}\n    // {{{ Line\n    Line(startPoint, endPoint, isIntersected) {\n      return {\n        startPoint: startPoint,\n        endPoint: endPoint,\n        isIntersected: isIntersected\n      };\n    },\n    // }}}\n    // {{{ drawLine\n    drawLine(x1, y1, x2, y2, isIntersected) {\n      this.context.shadowColor = isIntersected ? \"#5D717133\" : \"#C9F32D33\";\n      this.context.shadowBlur = 6;\n      this.context.shadowOffsetX = 0;\n      this.context.shadowOffsetY = 0;\n      this.context.setLineDash([4, 4]);\n      this.context.beginPath();\n      this.context.moveTo(x1, y1);\n      this.context.lineTo(x2, y2);\n      this.context.lineWidth = 2;\n      this.context.strokeStyle = isIntersected ? \"#5D7171\" : \"#C9F32D\";\n      this.context.stroke();\n    },\n    // }}}\n    // {{{ generatePoints\n    generatePoints() {\n      for (var i = 0; i < this.pointsCount; i++) {\n        var x = 30 + Math.floor(Math.random() * (this.canvasWidth - 60));\n        var y = 30 + Math.floor(Math.random() * (this.canvasHeight - 60));\n        this.points.push(new Point(x, y));\n      }\n    },\n    // }}}\n    // {{{ arrangePoints\n    arrangePoints() {\n      for (let i = 0; i < this.pointsCount - 4; i++) {\n        let x = Math.floor(this.canvasWidth / 2 + 150 * Math.cos(2 * Math.PI * i / (this.pointsCount - 4)));\n        let y = Math.floor(this.canvasHeight / 2 + 150 * Math.sin(2 * Math.PI * i / (this.pointsCount - 4)));\n        this.points[i] = new Point(x, y);\n      }\n      for (let i = 0; i < 4; i++) {\n        let x = Math.floor(this.canvasWidth / 2 + 70 * Math.cos(2 * Math.PI * i / 4));\n        let y = Math.floor(this.canvasHeight / 2 + 70 * Math.sin(2 * Math.PI * i / 4));\n        this.points[this.pointsCount - i - 1] = new Point(x, y);\n      }\n    },\n    // }}}\n    // {{{ connectPoints\n    connectPoints() {\n      // populate this.lines[] with points based on trianglulated edges\n      this.lines = [];\n      this.edges.forEach(([a, b]) => {\n        this.lines.push(this.Line(this.points[a], this.points[b], false));\n      });\n    },\n    // }}}\n    // {{{ triangulate\n    triangulate() {\n      // use cdt2d to draw Delaunay Triangulation to ensure a planar graph\n      // var points = [ [-2, -2], [-2, 2], [2, 2], [2, -2], [1, 0], [0, 1], [-1, 0], [0, -1] ]\n      this.lines = [];\n      var coordinates = this.points.map(({\n        x,\n        y\n      }) => {\n        return [x, y];\n      });\n      var triangles = cdt2d(coordinates, this.edges || [], {\n        exterior: true\n      });\n      var edges = [];\n      triangles.forEach(([a, b, c]) => {\n        edges.push([a, b]);\n        edges.push([b, c]);\n        edges.push([c, a]);\n      });\n      if (!this.edges) {\n        this.edges = edges;\n      }\n    },\n    // }}}\n    // {{{ playWin\n    playWin() {\n      this.finishedGame = true;\n      this.$emit(\"onFinishGame\");\n    },\n    // }}}\n    // {{{ updateLineIntersection\n    // checking lines intersection between all points O(n^2)\n    updateLineIntersection() {\n      this.intersectedCount = 0;\n      for (var i = 0; i < this.lines.length; i++) {\n        let line1 = this.lines[i];\n        line1.isIntersected = false;\n        for (var j = 0; j < i; j++) {\n          var line2 = this.lines[j];\n\n          // we check if two lines are intersected and bold the line if they are.\n          if (this.isIntersect(line1, line2)) {\n            this.intersectedCount = this.intersectedCount + 1;\n            line1.isIntersected = true;\n            line2.isIntersected = true;\n            this.lines[i] = line1;\n            this.lines[j] = line2;\n          }\n        }\n      }\n    },\n    // }}}\n    // {{{ drawAllLines\n    drawAllLines() {\n      this.updateLineIntersection();\n      this.lines.forEach(({\n        startPoint,\n        endPoint,\n        isIntersected\n      }) => {\n        this.drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, isIntersected);\n      });\n    },\n    // }}}\n    // {{{ drawAllNodes\n    drawAllNodes() {\n      this.context.save();\n      this.connectPoints();\n      this.drawAllLines();\n      for (let point of this.points) {\n        this.drawCircle(point, this.pointSize);\n      }\n      this.context.restore();\n    }\n    // }}}\n  }\n};","map":null,"metadata":{},"sourceType":"module"}