{"ast":null,"code":"import lineItem from \"./Assets/lineItem.vue\";\nimport Attemp from \"./Assets/Attemp.vue\";\nexport default {\n  data() {\n    return {\n      cells: [],\n      isTest: false,\n      targetCells: [],\n      canvas: null,\n      ctx: null,\n      currentStep: 1,\n      step: 1,\n      clickedList: [],\n      excludedPolygon: [[178, 2], [96, 41], [10, 187], [6, 208], [116, 239], [102, 497], [414, 500], [400, 342], [402, 230], [492, 200], [405, 37], [323, 4], [279, 3], [194, 1], [168, 1]],\n      coutnOfErrors: 0,\n      coordsData: [0, 0],\n      priciusCoords: null,\n      testProporsion: 2.65,\n      isStepEnd: false\n    };\n  },\n  components: {\n    lineItem,\n    Attemp\n  },\n  props: {\n    sendedTargetCells: {\n      type: Array,\n      default: () => []\n    },\n    gameStep: {\n      type: Number,\n      default: 1\n    },\n    maxStep: {\n      type: Number,\n      default: 1\n    }\n  },\n  methods: {\n    remToPx(rem) {\n      const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize);\n      return baseFontSize * rem;\n    },\n    pxToRem(px) {\n      const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize);\n      return px / baseFontSize;\n    },\n    setCanvasSize() {\n      this.canvas = this.$refs.SewingCanvas;\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.canvas.width = this.remToPx(49.2);\n      this.canvas.height = this.remToPx(51.8);\n    },\n    filterFakeCells() {\n      this.cells = this.cells.filter((cell, i) => {\n        return this.clickedList.includes(i);\n      });\n    },\n    setError() {\n      this.coutnOfErrors++;\n      if (this.coutnOfErrors == 2) {\n        this.isStepEnd = true;\n        this.$emit(\"onEndGame\", 2 - this.coutnOfErrors);\n      }\n    },\n    onClick(cell, i) {\n      if (this.isStepEnd) return;\n      if (i == 0 && this.clickedList.length == this.targetCells.length) {\n        this.isStepEnd = true;\n        this.drawLine(cell);\n        this.filterFakeCells();\n        this.$emit(\"onEndGame\", 2 - this.coutnOfErrors);\n        return;\n      }\n      if (this.clickedList.includes(i)) {\n        this.setError();\n        return;\n      }\n      const targetCellIndex = this.targetCells.findIndex(targetCell => targetCell.x === cell.x && targetCell.y === cell.y);\n      if (targetCellIndex === -1) {\n        this.setError();\n        return;\n      }\n      const lastClickedItemIndex = this.clickedList[this.clickedList.length - 1];\n      const lastClickedItem = this.cells[lastClickedItemIndex];\n      const priviusTargetCell = this.targetCells[targetCellIndex - 1];\n      const nextTargetCell = this.targetCells[targetCellIndex + 1] || this.targetCells[0];\n      console.log(lastClickedItem, priviusTargetCell, nextTargetCell);\n      if (priviusTargetCell === lastClickedItem || nextTargetCell === lastClickedItem) {\n        console.log(\"priviusTargetCell === lastClickedItem || nextTargetCell === lastClickedItem\");\n      } else {\n        this.setError();\n        return;\n      }\n      this.clickedList.push(i);\n      if (!this.priciusCoords) {\n        this.priciusCoords = cell;\n        this.currentStep++;\n        return;\n      }\n      this.drawLine(cell);\n    },\n    drawLine(cell) {\n      const ctx = this.ctx;\n      ctx.beginPath();\n      ctx.setLineDash([15, 5]);\n      ctx.moveTo(this.remToPx(this.priciusCoords.x), this.remToPx(this.priciusCoords.y));\n      ctx.lineTo(this.remToPx(cell.x), this.remToPx(cell.y));\n      ctx.lineWidth = this.remToPx(0.2);\n      ctx.strokeStyle = \"#E32636\";\n      ctx.stroke();\n      ctx.closePath();\n      this.priciusCoords = cell;\n      this.step = 2;\n    },\n    setAnim() {\n      const canvas = this.$refs.SewingCanvasLine;\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      const anim = () => {\n        const rect = this.canvas.getBoundingClientRect();\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (!this.priciusCoords || !this.coordsData[0]) {\n          requestAnimationFrame(anim);\n          return;\n        }\n        ctx.beginPath();\n        ctx.setLineDash([1, 0]);\n        ctx.moveTo(this.remToPx(this.priciusCoords.x) + rect.left, this.remToPx(this.priciusCoords.y) + rect.top);\n        ctx.lineTo(this.coordsData[0], this.coordsData[1]);\n        ctx.lineWidth = this.remToPx(0.2);\n        ctx.strokeStyle = \"#E32636\";\n        ctx.stroke();\n        ctx.closePath();\n        if (!this.isStepEnd) {\n          requestAnimationFrame(anim);\n        } else {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n        }\n      };\n      requestAnimationFrame(anim);\n    },\n    setTest() {\n      const ctx = this.ctx;\n      const {\n        width,\n        height\n      } = this.canvas;\n      ctx.arc(width / 2, height / 2, this.remToPx(24), 0, 2 * Math.PI);\n      ctx.fillStyle = \"red\";\n      ctx.stroke();\n      const max = 50;\n      const stepW = width / max;\n      const stepH = height / max;\n      for (let i = 1; i <= max; i++) {\n        ctx.beginPath();\n        ctx.moveTo(stepW * i, 0);\n        ctx.lineTo(stepW * i, height);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(0, stepH * i);\n        ctx.lineTo(width, stepH * i);\n        ctx.stroke();\n      }\n    },\n    setCells() {\n      const cells = [...this.targetCells];\n      const isPointInsideCircle = (x, y, radius) => {\n        const centerX = 500 / 2;\n        const centerY = 500 / 2;\n        const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        return distance <= radius;\n      };\n      const doesCellIntersect = newCell => {\n        return cells.some(cell => {\n          const distance = Math.sqrt((cell.x - newCell.x) ** 2 + (cell.y - newCell.y) ** 2);\n          console.log(distance);\n          return distance < 2.5;\n        });\n      };\n      const generateRandomCoordinates = () => {\n        let x, y;\n        do {\n          x = Math.random() * 500;\n          y = Math.random() * 500;\n        } while (!isPointInsideCircle(x, y, 240) || doesCellIntersect({\n          x: x / 10,\n          y: y / 10\n        }));\n        return {\n          x,\n          y\n        };\n      };\n      const drawCells = () => {\n        this.cells = cells;\n      };\n      const numCells = 20;\n      for (let i = 0; i < numCells; i++) {\n        const {\n          x,\n          y\n        } = generateRandomCoordinates();\n        cells.push({\n          x: x / 10,\n          y: y / 10\n        });\n      }\n      drawCells();\n    },\n    setCanvasExample() {\n      const SewingCanvasLineExample = this.$refs.SewingCanvasLineExample;\n      const ctx = SewingCanvasLineExample.getContext(\"2d\");\n      SewingCanvasLineExample.width = this.remToPx(18.6);\n      SewingCanvasLineExample.height = this.remToPx(18.6);\n      ctx.beginPath();\n      this.targetCells.forEach(cell => {\n        ctx.lineTo(this.remToPx(cell.x) / this.testProporsion, this.remToPx(cell.y) / this.testProporsion);\n      });\n      ctx.lineTo(this.remToPx(this.targetCells[0].x) / this.testProporsion, this.remToPx(this.targetCells[0].y) / this.testProporsion);\n      ctx.strokeStyle = \"#E32636\";\n      ctx.stroke();\n    },\n    onMouseMove(e) {\n      this.coordsData = [e.clientX, e.clientY];\n    },\n    onMouseDown(e) {\n      if (!this.isTest) return;\n      const rect = this.canvas.getBoundingClientRect();\n      this.cells.push({\n        x: this.pxToRem(e.clientX - rect.left),\n        y: this.pxToRem(e.clientY - rect.top)\n      });\n      console.log(this.cells);\n    }\n  },\n  created() {\n    this.targetCells = this.sendedTargetCells;\n    console.log(this.targetCells);\n  },\n  mounted() {\n    this.targetCells = this.sendedTargetCells;\n    this.setCanvasSize();\n    this.setCanvasExample();\n    if (!this.isTest) {\n      this.setCells();\n      setTimeout(() => {\n        this.onClick(this.cells[0], 0);\n      }, 100);\n    }\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n    window.addEventListener(\"mousedown\", this.onMouseDown);\n    window.addEventListener(\"keydown\", e => {\n      if (e.key === \"Backspace\") {\n        this.cells.pop();\n      }\n    });\n    // this.setTest();\n    this.setAnim();\n  },\n  beforeUnmount() {\n    window.removeEventListener(\"mousemove\", this.onMouseMove);\n    window.removeEventListener(\"mousedown\", this.onMouseDown);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}