{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport MPSortSelect from \"@/Application/Pages/MarketPlace/Components/MP-SortSelect/MP-SortSelect.vue\";\nimport { Line } from \"vue-chartjs\";\nimport { Chart as ChartJS, Title, Tooltip, Legend, LineElement, PointElement, CategoryScale, LinearScale, Filler } from \"chart.js\";\nimport { parseDate } from \"@/Application/Pages/MarketPlace/Assets/functions\";\nChartJS.register(Title, Tooltip, Legend, LineElement, PointElement, CategoryScale, LinearScale, Filler);\nexport default {\n  name: \"MyChart\",\n  props: {\n    chartItems: {\n      type: Array,\n      required: true\n    }\n  },\n  components: {\n    LineChart: Line,\n    MPSortSelect\n  },\n  data() {\n    return {\n      selectData: {\n        title: \"Виберіть промежуток часу\",\n        options: [\"Рік\", \"Місяць\", \"День\"]\n      },\n      dateType: null,\n      dates: [],\n      values: [],\n      fontSize: 0\n    };\n  },\n  computed: {\n    chartData() {\n      return {\n        labels: this.dates,\n        datasets: [{\n          borderColor: \"rgb(0, 255, 255)\",\n          pointBorderColor: \"transparent\",\n          pointRadius: 9 * this.fontSize,\n          pointHitRadius: 40 * this.fontSize,\n          pointHoverBorderWidth: 9 * this.fontSize,\n          pointBackgroundColor: \"transparent\",\n          pointHoverBorderColor: \"rgba(0, 255, 255, 0.24)\",\n          pointHoverBackgroundColor: \"white\",\n          borderWidth: 3 * this.fontSize,\n          hoverRadius: 12 * this.fontSize,\n          data: this.values,\n          tension: 0.4,\n          showLine: true,\n          spanGaps: true,\n          fill: true,\n          backgroundColor: ctx => {\n            const gradient = ctx.chart.ctx.createLinearGradient(0, 0, 0, ctx.chart.height);\n            gradient.addColorStop(0, \"rgba(0, 255, 255, 0.12)\");\n            gradient.addColorStop(1, \"rgba(0, 255, 255, 0.00)\");\n            return gradient;\n          }\n        }]\n      };\n    },\n    chartOptions() {\n      return {\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins: {\n          legend: {\n            display: false\n          },\n          tooltip: {\n            displayColors: false,\n            backgroundColor: \"white\",\n            bodyColor: \"black\",\n            bodyAlign: \"center\",\n            caretSize: 0,\n            boxPadding: 20,\n            padding: {\n              top: 8.5 * this.fontSize,\n              left: 12 * this.fontSize,\n              bottom: 8.5 * this.fontSize,\n              right: 12 * this.fontSize\n            },\n            bodyFont: {\n              size: 14 * this.fontSize,\n              weight: 700\n            },\n            callbacks: {\n              label: function (context) {\n                if (context.raw >= 1000) {\n                  const formattedValue = (context.raw / 1000).toFixed(1);\n                  return `$${formattedValue.endsWith(\".0\") ? formattedValue.slice(0, -2) + \"K\" : formattedValue + \"K\"}`;\n                }\n                return `$${context.raw}`;\n              },\n              title: function () {\n                return \"\";\n              }\n            }\n          }\n        },\n        scales: {\n          x: {\n            ticks: {\n              color: \"white\",\n              font: {\n                size: 14 * this.fontSize,\n                weight: 700\n              },\n              padding: 10 * this.fontSize\n            },\n            offset: false,\n            grid: {\n              color: \"transparent\",\n              drawBorder: false\n            }\n          },\n          y: {\n            ticks: {\n              color: \"white\",\n              font: {\n                size: 16 * this.fontSize,\n                weight: 700\n              },\n              padding: 20 * this.fontSize,\n              callback: function (value) {\n                if (value >= 1000) {\n                  const formattedValue = (value / 1000).toFixed(1);\n                  return `$${formattedValue.endsWith(\".0\") ? formattedValue.slice(0, -2) + \"K\" : formattedValue + \"K\"}`;\n                }\n                return `$${value}`;\n              }\n            },\n            beginAtZero: true,\n            grid: {\n              color: \"transparent\"\n            }\n          }\n        }\n      };\n    }\n  },\n  watch: {\n    chartItems: {\n      handler(newVal) {\n        this.setChartItems();\n      },\n      deep: true\n    }\n  },\n  methods: {\n    setDateType(type) {\n      this.dateType = type;\n    },\n    onResize() {\n      const fontSize = getComputedStyle(document.documentElement).fontSize;\n      const size = Number(fontSize.slice(0, -2)) / 10;\n      this.fontSize = size;\n    },\n    setChartItems() {\n      if (Array.isArray(this.chartItems) && this.chartItems?.length) {\n        const dateTypes = {\n          year: \"month\",\n          month: \"day\",\n          day: \"time\"\n        };\n        const dates = [];\n        const values = [];\n        this.chartItems.forEach(item => {\n          values.push(item.value);\n          dates.push(parseDate(item.date, dateTypes[this.dateType]));\n        });\n        this.dates = dates;\n        this.values = values;\n      }\n    }\n  },\n  mounted() {\n    window.addEventListener(\"resize\", this.onResize);\n    this.onResize();\n    this.setChartItems();\n  },\n  unmounted() {\n    window.removeEventListener(\"resize\", this.onResize);\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}