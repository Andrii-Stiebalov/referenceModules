{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  data() {\n    return {\n      cells: [],\n      canvas: null,\n      ctx: null,\n      currentStep: 1,\n      step: 1,\n      excludedPolygon: [[178, 2], [96, 41], [10, 187], [6, 208], [116, 239], [102, 497], [414, 500], [400, 342], [402, 230], [492, 200], [405, 37], [323, 4], [279, 3], [194, 1], [168, 1]],\n      coordsData: [0, 0],\n      priciusCoords: null\n    };\n  },\n  methods: {\n    remToPx(rem) {\n      const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize);\n      console.log(baseFontSize * rem);\n      return baseFontSize * rem;\n    },\n    setCanvasSize() {\n      this.canvas = this.$refs.SewingCanvas;\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.canvas.width = this.remToPx(49.2);\n      this.canvas.height = this.remToPx(51.8);\n    },\n    drawLine(cell, i) {\n      if (this.currentStep !== i + 1) {\n        return;\n      }\n      if (this.step === 2 && this.priciusCoords) {\n        this.step = 1;\n        this.currentStep++;\n        return;\n      }\n      if (!this.priciusCoords) {\n        this.priciusCoords = cell;\n        this.currentStep++;\n        return;\n      }\n      const ctx = this.ctx;\n      ctx.beginPath();\n      ctx.setLineDash([15, 5]);\n      ctx.moveTo(this.priciusCoords.x, this.priciusCoords.y);\n      ctx.lineTo(cell.x, cell.y);\n      console.log(\"WRITE\");\n      ctx.lineWidth = 1;\n      ctx.stroke();\n      ctx.closePath();\n      this.priciusCoords = cell;\n      this.step = 2;\n    },\n    setAnim() {\n      const canvas = this.$refs.SewingCanvasLine;\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      const anim = () => {\n        const rect = this.canvas.getBoundingClientRect();\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (!this.priciusCoords || this.step == 2) {\n          requestAnimationFrame(anim);\n          return;\n        }\n        ctx.beginPath();\n        ctx.setLineDash([1, 0]);\n        ctx.moveTo(this.priciusCoords.x + rect.left, this.priciusCoords.y + rect.top);\n        ctx.lineTo(this.coordsData[0], this.coordsData[1]);\n        console.log(rect);\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        ctx.closePath();\n        requestAnimationFrame(anim);\n        console.log();\n      };\n      requestAnimationFrame(anim);\n    },\n    setTest() {\n      const ctx = this.ctx;\n      this.excludedPolygon.forEach((cell, i) => {\n        ctx.strokeStyle = \"blue\";\n        if (!i) {\n          ctx.moveTo(cell[0], cell[1]);\n        } else {\n          ctx.lineTo(cell[0], cell[1]);\n        }\n      });\n      ctx.stroke();\n    },\n    setCells() {\n      // Функция для проверки, находится ли точка внутри полигона\n      const cells = [];\n      const isPointInsidePolygon = (x, y) => {\n        let inside = false;\n        for (let i = 0, j = this.excludedPolygon.length - 1; i < this.excludedPolygon.length; j = i++) {\n          const xi = this.excludedPolygon[i][0];\n          const yi = this.excludedPolygon[i][1];\n          const xj = this.excludedPolygon[j][0];\n          const yj = this.excludedPolygon[j][1];\n          const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n          if (intersect) inside = !inside;\n        }\n        return inside;\n      };\n      const cellWidth = this.remToPx(2.8);\n      const cellHeight = this.remToPx(2.8);\n      const cellMargin = 15;\n\n      // Функция для проверки пересечения прямоугольников\n      function isRectIntersecting(rect1, rect2) {\n        return !(rect2.x > rect1.x + cellWidth + 20 || rect2.x + cellWidth + 20 < rect1.x || rect2.y > rect1.y + cellHeight + 25 || rect2.y + cellHeight + 25 < rect1.y);\n      }\n\n      // Функция для генерации случайных координат для новой ячейки с учетом отступов\n      const generateRandomCoordinates = () => {\n        let x, y;\n        do {\n          x = Math.random() * (this.canvas.width - cellWidth - cellMargin * 2) + cellMargin;\n          y = Math.random() * (this.canvas.height - cellHeight - cellMargin * 2) + cellMargin;\n        } while (!isPointInsidePolygon(x, y) || cells.some(cell => isRectIntersecting(cell, {\n          x,\n          y\n        })));\n        return {\n          x,\n          y\n        };\n      };\n\n      // Функция для отрисовки всех ячеек из массива\n      const drawCells = () => {\n        this.cells = cells;\n      };\n      const numCells = 18;\n      for (let i = 0; i < numCells; i++) {\n        const {\n          x,\n          y\n        } = generateRandomCoordinates();\n        cells.push({\n          x,\n          y\n        });\n      }\n      drawCells(); // Отрисовка начальных ячеек\n    },\n    onMouseMove(e) {\n      this.coordsData = [e.clientX, e.clientY];\n    }\n  },\n  mounted() {\n    this.setCanvasSize();\n    this.setCells();\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n    // this.setTest();\n    this.setAnim();\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}