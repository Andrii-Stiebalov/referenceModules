{"ast":null,"code":"import { registerRuntimeHelpers, isBuiltInType, createSimpleExpression, createCompilerError, createObjectProperty, getConstantType, createCallExpression, TO_DISPLAY_STRING, transformModel as transformModel$1, findProp, hasDynamicKeyVBind, transformOn as transformOn$1, createCompoundExpression, isStaticExp, checkCompatEnabled, noopDirectiveTransform, baseCompile, baseParse } from '@vue/compiler-core';\nexport * from '@vue/compiler-core';\nimport { isVoidTag, isHTMLTag, isSVGTag, makeMap, parseStringStyle, capitalize, extend } from '@vue/shared';\nconst V_MODEL_RADIO = Symbol(process.env.NODE_ENV !== 'production' ? `vModelRadio` : ``);\nconst V_MODEL_CHECKBOX = Symbol(process.env.NODE_ENV !== 'production' ? `vModelCheckbox` : ``);\nconst V_MODEL_TEXT = Symbol(process.env.NODE_ENV !== 'production' ? `vModelText` : ``);\nconst V_MODEL_SELECT = Symbol(process.env.NODE_ENV !== 'production' ? `vModelSelect` : ``);\nconst V_MODEL_DYNAMIC = Symbol(process.env.NODE_ENV !== 'production' ? `vModelDynamic` : ``);\nconst V_ON_WITH_MODIFIERS = Symbol(process.env.NODE_ENV !== 'production' ? `vOnModifiersGuard` : ``);\nconst V_ON_WITH_KEYS = Symbol(process.env.NODE_ENV !== 'production' ? `vOnKeysGuard` : ``);\nconst V_SHOW = Symbol(process.env.NODE_ENV !== 'production' ? `vShow` : ``);\nconst TRANSITION = Symbol(process.env.NODE_ENV !== 'production' ? `Transition` : ``);\nconst TRANSITION_GROUP = Symbol(process.env.NODE_ENV !== 'production' ? `TransitionGroup` : ``);\nregisterRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n});\n\n/* eslint-disable no-restricted-globals */\nlet decoder;\nfunction decodeHtmlBrowser(raw, asAttr = false) {\n  if (!decoder) {\n    decoder = document.createElement('div');\n  }\n  if (asAttr) {\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`;\n    return decoder.children[0].getAttribute('foo');\n  } else {\n    decoder.innerHTML = raw;\n    return decoder.textContent;\n  }\n}\nconst isRawTextContainer = /*#__PURE__*/makeMap('style,iframe,script,noscript', true);\nconst parserOptions = {\n  isVoidTag,\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n  isPreTag: tag => tag === 'pre',\n  decodeEntities: decodeHtmlBrowser,\n  isBuiltInComponent: tag => {\n    if (isBuiltInType(tag, `Transition`)) {\n      return TRANSITION;\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP;\n    }\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag, parent) {\n    let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;\n    if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return 1 /* DOMNamespaces.SVG */;\n        }\n        if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ && a.name === 'encoding' && a.value != null && (a.value.content === 'text/html' || a.value.content === 'application/xhtml+xml'))) {\n          ns = 0 /* DOMNamespaces.HTML */;\n        }\n      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== 'mglyph' && tag !== 'malignmark') {\n        ns = 0 /* DOMNamespaces.HTML */;\n      }\n    } else if (parent && ns === 1 /* DOMNamespaces.SVG */) {\n      if (parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title') {\n        ns = 0 /* DOMNamespaces.HTML */;\n      }\n    }\n    if (ns === 0 /* DOMNamespaces.HTML */) {\n      if (tag === 'svg') {\n        return 1 /* DOMNamespaces.SVG */;\n      }\n      if (tag === 'math') {\n        return 2 /* DOMNamespaces.MATH_ML */;\n      }\n    }\n    return ns;\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode({\n    tag,\n    ns\n  }) {\n    if (ns === 0 /* DOMNamespaces.HTML */) {\n      if (tag === 'textarea' || tag === 'title') {\n        return 1 /* TextModes.RCDATA */;\n      }\n      if (isRawTextContainer(tag)) {\n        return 2 /* TextModes.RAWTEXT */;\n      }\n    }\n    return 0 /* TextModes.DATA */;\n  }\n};\n\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nconst transformStyle = node => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */) {\n    node.props.forEach((p, i) => {\n      if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        node.props[i] = {\n          type: 7 /* NodeTypes.DIRECTIVE */,\n          name: `bind`,\n          arg: createSimpleExpression(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        };\n      }\n    });\n  }\n};\nconst parseInlineCSS = (cssText, loc) => {\n  const normalized = parseStringStyle(cssText);\n  return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);\n};\nfunction createDOMCompilerError(code, loc) {\n  return createCompilerError(code, loc, process.env.NODE_ENV !== 'production' || !true ? DOMErrorMessages : undefined);\n}\nconst DOMErrorMessages = {\n  [50 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\n  [51 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\n  [52 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\n  [53 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\n  [54 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [55 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\n  [56 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [57 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [58 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\n  [59 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\n  [60 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n};\nconst transformVHtml = (dir, node, context) => {\n  const {\n    exp,\n    loc\n  } = dir;\n  if (!exp) {\n    context.onError(createDOMCompilerError(50 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));\n  }\n  if (node.children.length) {\n    context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));\n    node.children.length = 0;\n  }\n  return {\n    props: [createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))]\n  };\n};\nconst transformVText = (dir, node, context) => {\n  const {\n    exp,\n    loc\n  } = dir;\n  if (!exp) {\n    context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));\n  }\n  if (node.children.length) {\n    context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));\n    node.children.length = 0;\n  }\n  return {\n    props: [createObjectProperty(createSimpleExpression(`textContent`, true), exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression('', true))]\n  };\n};\nconst transformModel = (dir, node, context) => {\n  const baseResult = transformModel$1(dir, node, context);\n  // base transform has errors OR component v-model (only need props)\n  if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {\n    return baseResult;\n  }\n  if (dir.arg) {\n    context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\n  }\n  function checkDuplicatedValue() {\n    const value = findProp(node, 'value');\n    if (value) {\n      context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\n    }\n  }\n  const {\n    tag\n  } = node;\n  const isCustomElement = context.isCustomElement(tag);\n  if (tag === 'input' || tag === 'textarea' || tag === 'select' || isCustomElement) {\n    let directiveToUse = V_MODEL_TEXT;\n    let isInvalidType = false;\n    if (tag === 'input' || isCustomElement) {\n      const type = findProp(node, `type`);\n      if (type) {\n        if (type.type === 7 /* NodeTypes.DIRECTIVE */) {\n          // :type=\"foo\"\n          directiveToUse = V_MODEL_DYNAMIC;\n        } else if (type.value) {\n          switch (type.value.content) {\n            case 'radio':\n              directiveToUse = V_MODEL_RADIO;\n              break;\n            case 'checkbox':\n              directiveToUse = V_MODEL_CHECKBOX;\n              break;\n            case 'file':\n              isInvalidType = true;\n              context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\n              break;\n            default:\n              // text type\n              process.env.NODE_ENV !== 'production' && checkDuplicatedValue();\n              break;\n          }\n        }\n      } else if (hasDynamicKeyVBind(node)) {\n        // element has bindings with dynamic keys, which can possibly contain\n        // \"type\".\n        directiveToUse = V_MODEL_DYNAMIC;\n      } else {\n        // text type\n        process.env.NODE_ENV !== 'production' && checkDuplicatedValue();\n      }\n    } else if (tag === 'select') {\n      directiveToUse = V_MODEL_SELECT;\n    } else {\n      // textarea\n      process.env.NODE_ENV !== 'production' && checkDuplicatedValue();\n    }\n    // inject runtime directive\n    // by returning the helper symbol via needRuntime\n    // the import will replaced a resolveDirective call.\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse);\n    }\n  } else {\n    context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\n  }\n  // native vmodel doesn't need the `modelValue` props since they are also\n  // passed to the runtime as `binding.value`. removing it reduces code size.\n  baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.key.content === 'modelValue'));\n  return baseResult;\n};\nconst isEventOptionModifier = /*#__PURE__*/makeMap(`passive,once,capture`);\nconst isNonKeyModifier = /*#__PURE__*/makeMap(\n// event propagation management\n`stop,prevent,self,` +\n// system modifiers + exact\n`ctrl,shift,alt,meta,exact,` +\n// mouse\n`middle`);\n// left & right could be mouse or key modifiers based on event type\nconst maybeKeyModifier = /*#__PURE__*/makeMap('left,right');\nconst isKeyboardEvent = /*#__PURE__*/makeMap(`onkeyup,onkeydown,onkeypress`, true);\nconst resolveModifiers = (key, modifiers, context, loc) => {\n  const keyModifiers = [];\n  const nonKeyModifiers = [];\n  const eventOptionModifiers = [];\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i];\n    if (modifier === 'native' && checkCompatEnabled(\"COMPILER_V_ON_NATIVE\" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {\n      eventOptionModifiers.push(modifier);\n    } else if (isEventOptionModifier(modifier)) {\n      // eventOptionModifiers: modifiers for addEventListener() options,\n      // e.g. .passive & .capture\n      eventOptionModifiers.push(modifier);\n    } else {\n      // runtimeModifiers: modifiers that needs runtime guards\n      if (maybeKeyModifier(modifier)) {\n        if (isStaticExp(key)) {\n          if (isKeyboardEvent(key.content)) {\n            keyModifiers.push(modifier);\n          } else {\n            nonKeyModifiers.push(modifier);\n          }\n        } else {\n          keyModifiers.push(modifier);\n          nonKeyModifiers.push(modifier);\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier);\n        } else {\n          keyModifiers.push(modifier);\n        }\n      }\n    }\n  }\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  };\n};\nconst transformClick = (key, event) => {\n  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';\n  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? createCompoundExpression([`(`, key, `) === \"onClick\" ? \"${event}\" : (`, key, `)`]) : key;\n};\nconst transformOn = (dir, node, context) => {\n  return transformOn$1(dir, node, context, baseResult => {\n    const {\n      modifiers\n    } = dir;\n    if (!modifiers.length) return baseResult;\n    let {\n      key,\n      value: handlerExp\n    } = baseResult.props[0];\n    const {\n      keyModifiers,\n      nonKeyModifiers,\n      eventOptionModifiers\n    } = resolveModifiers(key, modifiers, context, dir.loc);\n    // normalize click.right and click.middle since they don't actually fire\n    if (nonKeyModifiers.includes('right')) {\n      key = transformClick(key, `onContextmenu`);\n    }\n    if (nonKeyModifiers.includes('middle')) {\n      key = transformClick(key, `onMouseup`);\n    }\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);\n    }\n    if (keyModifiers.length && (\n    // if event name is dynamic, always wrap with keys guard\n    !isStaticExp(key) || isKeyboardEvent(key.content))) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);\n    }\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join('');\n      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\n    }\n    return {\n      props: [createObjectProperty(key, handlerExp)]\n    };\n  });\n};\nconst transformShow = (dir, node, context) => {\n  const {\n    exp,\n    loc\n  } = dir;\n  if (!exp) {\n    context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));\n  }\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  };\n};\nconst transformTransition = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 1 /* ElementTypes.COMPONENT */) {\n    const component = context.isBuiltInComponent(node.tag);\n    if (component === TRANSITION) {\n      return () => {\n        if (!node.children.length) {\n          return;\n        }\n        // warn multiple transition children\n        if (hasMultipleChildren(node)) {\n          context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {\n            start: node.children[0].loc.start,\n            end: node.children[node.children.length - 1].loc.end,\n            source: ''\n          }));\n        }\n        // check if it's s single child w/ v-show\n        // if yes, inject \"persisted: true\" to the transition props\n        const child = node.children[0];\n        if (child.type === 1 /* NodeTypes.ELEMENT */) {\n          for (const p of child.props) {\n            if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {\n              node.props.push({\n                type: 6 /* NodeTypes.ATTRIBUTE */,\n                name: 'persisted',\n                value: undefined,\n                loc: node.loc\n              });\n            }\n          }\n        }\n      };\n    }\n  }\n};\nfunction hasMultipleChildren(node) {\n  // #1352 filter out potential comment nodes.\n  const children = node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ && !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim()));\n  const child = children[0];\n  return children.length !== 1 || child.type === 11 /* NodeTypes.FOR */ || child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren);\n}\nconst ignoreSideEffectTags = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 0 /* ElementTypes.ELEMENT */ && (node.tag === 'script' || node.tag === 'style')) {\n    context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\n    context.removeNode();\n  }\n};\nconst DOMNodeTransforms = [transformStyle, ...(process.env.NODE_ENV !== 'production' ? [transformTransition] : [])];\nconst DOMDirectiveTransforms = {\n  cloak: noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel,\n  on: transformOn,\n  show: transformShow\n};\nfunction compile(template, options = {}) {\n  return baseCompile(template, extend({}, parserOptions, options, {\n    nodeTransforms: [\n    // ignore <script> and <tag>\n    // this is not put inside DOMNodeTransforms because that list is used\n    // by compiler-ssr to generate vnode fallback branches\n    ignoreSideEffectTags, ...DOMNodeTransforms, ...(options.nodeTransforms || [])],\n    directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\n    transformHoist: null\n  }));\n}\nfunction parse(template, options = {}) {\n  return baseParse(template, extend({}, parserOptions, options));\n}\nexport { DOMDirectiveTransforms, DOMNodeTransforms, TRANSITION, TRANSITION_GROUP, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, compile, createDOMCompilerError, parse, parserOptions, transformStyle };","map":null,"metadata":{},"sourceType":"module"}