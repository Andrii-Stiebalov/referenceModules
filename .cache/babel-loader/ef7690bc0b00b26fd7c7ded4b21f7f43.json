{"ast":null,"code":"import \"./builder.scss\";\nexport default {\n  data() {\n    return {\n      active: true,\n      locale: 'ua',\n      brick: '',\n      brickList: ['brick-1.svg', 'brick-2.svg', 'brick-3.svg', 'brick-4.svg'],\n      brickTransition: 3.5,\n      brickTransitionType: 'linear',\n      distanceBetweenBricks: 2,\n      bricksOnOneLineCountMax: 11,\n      scoreToWin: 4,\n      sounds: ['1.mp3', '2.mp3', '3.mp3', '4.mp3'],\n      inGameProvider: {\n        status: false,\n        bricksGenerate: [],\n        fallingBrickPosition: 0,\n        intervalDistance: null,\n        score: 0\n      }\n    };\n  },\n  methods: {\n    startGame() {\n      !this.inGameProvider.status ? this.inGameProvider.status = true : null;\n      this.$nextTick(() => {\n        this.inGameProvider.bricksGenerate = this.bricksGenerate();\n        this.game();\n      });\n    },\n    endGame(status) {\n      this.inGameProvider.intervalDistance && clearInterval(this.inGameProvider.intervalDistance);\n      this.$callClient(\"Builder:statusGame\", status ? status : false);\n    },\n    game() {\n      this.resetBrickPosition();\n      this.brick = this.getBrick();\n      this.inGameProvider.fallingBrickPosition = this.getRandom(0, this.bricksOnOneLineCountMax - 1); // -1 for prevent departure abroad\n      this.$refs.divFallingBrick.style.left = `${this.inGameProvider.fallingBrickPosition * (this.$refs.divFallingBrick.offsetWidth + this.distanceBetweenBricks)}px`;\n      this.$refs.divFallingBrick.style.transition = `bottom ${this.brickTransition}s ${this.brickTransitionType}`;\n      this.$refs.divFallingBrick.style.bottom = '0vw';\n      this.inGameProvider.intervalDistance && clearInterval(this.inGameProvider.intervalDistance);\n      this.inGameProvider.intervalDistance = setInterval(() => {\n        if (this.$refs.divFallingBrick.offsetTop >= this.$refs.divBricksCells.getBoundingClientRect().top - this.$refs.divBricksCells.offsetHeight * 2.1) {\n          let findIndexBrickSuccess = this.inGameProvider.bricksGenerate.indexOf('brick-success.svg');\n          if (this.inGameProvider.fallingBrickPosition === findIndexBrickSuccess) {\n            this.inGameProvider.score++;\n            if (this.inGameProvider.score >= this.scoreToWin) {\n              this.inGameProvider.bricksGenerate[findIndexBrickSuccess] = this.brick;\n              this.endGame(true);\n            } else {\n              this.inGameProvider.bricksGenerate[findIndexBrickSuccess] = this.brick;\n              this.inGameProvider.bricksGenerate.splice(this.getDangerBrick(), 1, 'brick-success.svg');\n              this.$refs.audioBuilder.src = `sounds/Builder/${this.sounds[this.getRandom(0, this.sounds.length - 1)]}`;\n              this.$refs.audioBuilder.play();\n              this.game();\n            }\n          } else {\n            this.endGame(false);\n          }\n        }\n      }, 100);\n    },\n    pxToVw(value, viewport) {\n      return Number(value / viewport * 100).toFixed(2);\n    },\n    getBrick() {\n      return this.brickList[Math.floor(Math.random() * this.brickList.length)];\n    },\n    getDangerBrick() {\n      this.bricksIndex = this.inGameProvider.bricksGenerate.reduce((a, b, c) => {\n        if (b === 'brick-danger.svg') {\n          a.push(c);\n        }\n        return a;\n      }, []);\n      return this.bricksIndex[Math.floor(Math.random() * this.bricksIndex.length)];\n    },\n    bricksGenerate() {\n      this.bricksFillArr = [];\n      for (let i = 0; i < this.bricksOnOneLineCountMax; i++) {\n        this.bricksFillArr.push(this.brickList[Math.floor(Math.random() * this.brickList.length)]);\n        if (i < this.scoreToWin) {\n          this.bricksFillArr[i] = 'brick-danger.svg';\n        }\n      }\n      this.bricksFillArr.sort(() => Math.random() - 0.5);\n      let findDangerBrick = this.bricksFillArr.findIndex(a => a === 'brick-danger.svg');\n      this.bricksFillArr[findDangerBrick] = 'brick-success.svg';\n      return this.bricksFillArr;\n    },\n    resetBrickPosition() {\n      this.$refs.divFallingBrick.style.transition = `bottom 0s ${this.brickTransitionType}`;\n      this.$refs.divFallingBrick.style.bottom = '100%';\n    },\n    resetGame() {\n      this.brick = '';\n      this.inGameProvider.score = 0;\n      this.inGameProvider.fallingBrickPosition = 0;\n      this.inGameProvider.status = false;\n      clearInterval(this.inGameProvider.intervalDistance);\n    },\n    getRandom(min, max) {\n      return Number(Math.floor((Math.random() * (max - min) + min).toFixed(1)));\n    },\n    onKeyUp(e) {\n      if (e.keyCode === 27 && !window.isModalShow) {\n        // Escape\n        if (this.active) {\n          if (this.inGameProvider.status) {\n            this.endGame(false);\n          } else {\n            this.endGame();\n          }\n        }\n      }\n      if (e.keyCode === 32) {\n        // Space\n        if (this.active) {\n          if (!this.inGameProvider.status) {\n            this.startGame();\n          }\n        }\n      }\n      if (e.keyCode === 65 || e.keyCode === 37) {\n        // A/Arrow left\n        if (this.$refs.divFallingBrick.offsetLeft > 0) {\n          this.inGameProvider.fallingBrickPosition--;\n          this.$refs.divFallingBrick.style.left = `${this.$refs.divFallingBrick.offsetLeft - this.$refs.divFallingBrick.offsetWidth - this.distanceBetweenBricks}px`;\n        }\n      }\n      if (e.keyCode === 68 || e.keyCode === 39) {\n        // D/Arrow right\n        if (this.$refs.divFallingBrick.offsetLeft < window.innerWidth - this.$refs.divFallingBrick.offsetWidth) {\n          this.inGameProvider.fallingBrickPosition++;\n          this.$refs.divFallingBrick.style.left = `${this.$refs.divFallingBrick.offsetLeft + this.$refs.divFallingBrick.offsetWidth + this.distanceBetweenBricks}px`;\n        }\n      }\n    }\n  },\n  mounted() {\n    window.addEventListener(\"keyup\", this.onKeyUp);\n  },\n  beforeUnmount() {\n    window.removeEventListener(\"keyup\", this.onKeyUp);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}